# Lishenko Practice Work 2
## Завдання 1
### для 64-бітної системи:

> Встановлюємо початковий час, який буде близкий до верхньої границі time_t у 64-бітній архітектурі
>
> При переповненні time_t на 64-бітній архітектурі (де максимальне значення для time_t складає 9223372036854775807), коли цей лічильник досягає свого максимального значення, він "переповнюється" і починає відлік з мінімального значення для 64-бітного типу — -9223372036854775808.

![image](https://github.com/user-attachments/assets/edbe8dbd-72f4-450b-aaab-65769bb5422b)


### для 32-бітної:

> Використовуємо додатковий флаг -m32 для компіляції у 32-бітній архітектурі 
>
![image](https://github.com/user-attachments/assets/315c6693-e5c3-4e02-96c9-0a42a1c28b60)

> Сегменти виконуваного файлу для 64-бітної архітектури використовують більше пам'яті:


![image](https://github.com/user-attachments/assets/e500cae5-fdda-46a8-a692-1efbedc239bc)




## Завдання 2
### 1

> Це проста програма, яка виводить "Hello, World!" на екран. У ній немає змінних або масивів.

![image](https://github.com/user-attachments/assets/b79a73d3-c1b4-40e9-9f2b-d09387655df1)


### 2

> Додаємо глобальний масив arr, який містить 1000 елементів типу int. Проте масив не ініціалізовано.
> 
> Масив буде розміщений у сегменті BSS

![image](https://github.com/user-attachments/assets/1ed00021-dc4e-4ab3-b0b6-d677c95bbec0)

### 3
> У цьому варіанті ми ініціалізуємо перший елемент масиву значенням 1, а решта елементів будуть ініціалізовані нулями за замовчуванням
> 
> Оскільки масив ініціалізовано, він буде розміщений у сегменті data (ініціалізовані змінні).

![image](https://github.com/user-attachments/assets/1fcaf4a4-1ca4-4496-ae2f-55da3f5eb0ee)


### 4 

> Додаємо локальний масив у функцію func(), ініціалізуючи його перший елемент значенням 1. Масив є локальним, тобто він існує тільки в межах функції.
> Локальні масиви не зберігаються в BSS чи data сегментах, оскільки вони використовують стек, який не зберігається у виконуваному файлі. Тому дані для таких масивів не зберігаються в самому виконуваному файлі.

![image](https://github.com/user-attachments/assets/8a1fbddc-bca7-48ea-8c42-2585bc1e3308)



### 5

> Додаємо флаги при компіляції програми:
>
> -g для налагодження;
>
> -O3 для оптимізації;

![image](https://github.com/user-attachments/assets/ef4a1c4d-249d-4873-89f8-0714f7d54191)

> використання пам'яті
> 
> для налагодження: не змінюється
> 
> для оптимизації: зменшуєтся обсяг використаної пам'яті

## Завдання 3

> Було скомпільована тестова програма, у якій ми дізналися приблизну адресу розташування стеку.

![image](https://github.com/user-attachments/assets/20e46877-7f49-4ed8-b565-39ce7fc64bcd)

> Далі було створено змінні різних типів для знаходження адрес стеку, купи та сегменту даних.

![image](https://github.com/user-attachments/assets/4937d78e-00f0-4bd1-aeb4-0164eb19fa11)

> Також було збільшено розмір стека, викликавши функцію й оголосивши кілька
> великих локальних масивів та знайдено остаточні адреси.

![image](https://github.com/user-attachments/assets/5ac4db54-aea7-4b6c-9ed9-bdbed38724c0)

## Завдання 4
> Досліджено стек вручну за допомогою налагоджувача GDB за допомогою команди backtrace.
> 
> Було запущено процес, який за допомогою системного виклику pause() було переведено у сплячий режим. В цей час використовуючи GDB, приєдналися до процесу.
> 
> За допомогою утиліти gstack не вдалося дослідити через ненаявність її підтримки на встановленій версії FreeBsd. 
> 
> GDB:

![image](https://github.com/user-attachments/assets/2f328d34-b5cb-434e-9b2e-7480e4278ec5)


## Завдання 5
> Вершина стека не може повністю замінити лічильник команд, оскільки стек зберігає тільки адреси повернення, але не вказує на поточну інструкцію в програмі.
> У програмі 5.с, файл якої прикріплений у цьому репозиторії, змінюємо код з завдання 4 так щоб замість IP використовувати вершину стеку. В цьому коді використовується стек для управління викликами функцій замість використання стандартного лічильника команд (IP), який > зазвичай вказує на поточну інструкцію. Однак, важливо розуміти, що стек і лічильник команд мають різні функції в процесі виконання програми, і в даному випадку, вершина стека допомагає зберігати адреси повернення з функцій, але не замінює безпосередньо IP для виконання поточних інструкцій.

## Завдання 6

> Варіант 11. Необхідно було реалізувати програму, що перевіряє випадкове розташування сегментів ASLR(Address Space Layout Randomization). 
> 
> Розроблена рограма перевіряє наявність ASLR, порівнюючи адреси для стека, купи та коду, отримані через функції. Якщо ці адреси різні, це означає, що ASLRувімкнений, оскільки кожен сегмент розміщується в випадкових місцях пам'яті при кожному запуску програми.

![image](https://github.com/user-attachments/assets/1d13b1d8-9aba-4004-b54d-8c54a94ec730)
